#!/usr/bin/env python

# JACoPO.py: calculation of electronic couplings with various approaches.
# Copyright (C) 2016  Daniele Padula, Marco Campetella
# dpadula85@yahoo.it, marco.campetella82@gmail.com
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import sys
import numpy as np

# Constants

au2ang = 0.5291771
au2wn = 2.194746e5


class Cube:
    def __init__(self, fname):

        f = open(fname, 'r')
        for i in range(2): f.readline()
        # number of atoms included in the file followed by the 
        # position of the origin of the volumetric data
        tkns = f.readline().split()
        self.natoms = int(tkns[0])
        self.origin = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])

        # The next three lines give the number of voxels 
        # along each axis (x, y, z) followed by the axis vector.
        tkns = f.readline().split() #
        self.NX = int(tkns[0])
        self.X = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])
        tkns = f.readline().split() #
        self.NY = int(tkns[0])
        self.Y = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])
        tkns = f.readline().split() #
        self.NZ = int(tkns[0])
        self.Z = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])

        # The last section in the header is one line for each atom consisting of 5 numbers, the 
        #first is the atom number, second (?), the last three are the x,y,z coordinates of the atom center.
        self.atoms = []
        for i in range(self.natoms):
            tkns = list(map(float, f.readline().split()))
            self.atoms.append([tkns[0], tkns[2], tkns[3], tkns[4]])

        # Other data
        self.atoms = np.array(self.atoms)
        self.grid = self.gen_grid()
        self.dV = self.X[0] * self.Y[1] * self.Z[2]
        self.coords = np.array([ [x[1], x[2], x[3]] for x in self.atoms ])

        # Volumetric data
        self.data = np.zeros((self.NX,self.NY,self.NZ))
        i=0
        for s in f:
            #print(s.split())
            for v in s.split():
                self.data[int(i/(self.NY*self.NZ)),
                          int((i/self.NZ)%self.NY),
                          int(i%self.NZ)] = float(v)
                i+=1

        self.data = self.data.reshape(self.NX * self.NY * self.NZ)
        if i != self.NX*self.NY*self.NZ: raise NameError("FSCK!")


    def gen_grid(self):

        grid = np.zeros((self.NX, self.NY, self.NZ, 3))
        for i in range(self.NX):
            for j in range(self.NY):
                for k in range(self.NZ):
                    grid[i,j,k,0] = self.origin[0] + i * self.X[0]
                    grid[i,j,k,1] = self.origin[1] + j * self.Y[1]
                    grid[i,j,k,2] = self.origin[2] + k * self.Z[2]

        N = self.NX * self.NY * self.NZ
        return grid.reshape(N, 3)


    def dump(self, fname):

        with open(fname, 'w') as f:
            # output Gaussian cube into file descriptor "f".
            # Usage pattern: f=open('filename.cube'); cube.dump(f); f.close()
            self.data = self.data.reshape(self.NX, self.NY, self.NZ)
            f.write("CUBE file\nGenerated by JACoPO.py\n")
            f.write("%5d %12.6f %12.6f %12.6f\n" % (self.natoms, self.origin[0], self.origin[1], self.origin[2]))
            f.write("%5d %12.6f %12.6f %12.6f\n"% (self.NX, self.X[0], self.X[1], self.X[2]))
            f.write("%5d %12.6f %12.6f %12.6f\n"% (self.NY, self.Y[0], self.Y[1], self.Y[2]))
            f.write("%5d %12.6f %12.6f %12.6f\n"% (self.NZ, self.Z[0], self.Z[1], self.Z[2]))
            for atom in self.atoms:
                f.write("%5d %12.6f %12.6f %12.6f %12.6f\n" % (atom[0], atom[0], atom[1], atom[2], atom[3]))
            for ix in range(self.NX):
                for iy in range(self.NY):
                    for iz in range(self.NZ):
                        f.write("%.5e " % self.data[ix,iy,iz])
                        if (iz % 6 == 5): f.write('\n')

def read_geo(geofile):

    checkfile(geofile)
    atgeo = np.loadtxt(geofile, usecols=[0], dtype=str)
    structgeo = np.loadtxt(geofile, usecols=[1,2,3]) / au2ang

    return atgeo, structgeo


def read_chg(chgfile):

    checkfile(chgfile)
    chgs = np.loadtxt(chgfile)

    return chgs


def read_sel(string):

    string =  ','.join(string).replace(',,',',')

    try:
        f = open(string, 'r')
        string = f.readlines()
        f.close()
        string =  ','.join(string).replace(',,',',')
        string = string.replace(',', ' ')
        string = list(map(lambda x: x - 1, extend_compact_list(string)))

    except IOError:
        string = string.replace(',', ' ')
        string = list(map(lambda x: x - 1, extend_compact_list(string)))

    return string


def extend_compact_list(idxs):

    extended = []

    # Uncomment this line if idxs is a string and not a list
    idxs = idxs.split()

    for idx in idxs:

        to_extend = idx.split('-')

        if len(to_extend) > 1:

            sel = list(map(int, to_extend))
            extended += range(sel[0],sel[1]+1,1)

        else:
        
            extended.append(int(idx))
    
    return extended


def checkfile(filename):

    if not os.path.isfile(filename):
        print(banner(text='ERROR', ch='#', length=80))
        print("File %s not found!" % filename)
        sys.exit()


def banner(text=None, ch='=', length=78):
    """Return a banner line centering the given text.
    
        "text" is the text to show in the banner. None can be given to have
            no text.
        "ch" (optional, default '=') is the banner line character (can
            also be a short string to repeat).
        "length" (optional, default 78) is the length of banner to make.

    Examples:
        >>> banner("Peggy Sue")
        '================================= Peggy Sue =================================='
        >>> banner("Peggy Sue", ch='-', length=50)
        '------------------- Peggy Sue --------------------'
        >>> banner("Pretty pretty pretty pretty Peggy Sue", length=40)
        'Pretty pretty pretty pretty Peggy Sue'
    """
    if text is None:
        return ch * length

    elif len(text) + 2 + len(ch)*2 > length:
        # Not enough space for even one line char (plus space) around text.
        return text

    else:
        remain = length - (len(text) + 2)
        prefix_len = remain / 2
        suffix_len = remain - prefix_len
    
        if len(ch) == 1:
            prefix = ch * prefix_len
            suffix = ch * suffix_len

        else:
            prefix = ch * (prefix_len/len(ch)) + ch[:prefix_len%len(ch)]
            suffix = ch * (suffix_len/len(ch)) + ch[:suffix_len%len(ch)]

        return prefix + ' ' + text + ' ' + suffix


if __name__ == '__main__':
    pass
