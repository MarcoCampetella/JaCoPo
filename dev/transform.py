#!/usr/bin/env python

import sys
import numpy as np

try:
    import trden
    FModule = True

except ImportError:
    print(" WARNING!!!")
    print(" The Fortran Module could not be loaded.")
    print(" Coupling from Transition Densities will not be computed.")
    FModule = False



au2ang = 0.5291771
au2wn = 2.194746e5


def extend_compact_list(idxs):

    extended = []

    # Uncomment this line if idxs is a string and not a list
    # idxs = idxs.split()

    for idx in idxs:

        to_extend = idx.split('-')

        if len(to_extend) > 1:

            sel =  map(int, to_extend)
            extended += range(sel[0],sel[1]+1,1)

        else:
        
            extended.append(int(idx))
    
    return extended


def kabsch(struct1, struct2):
    '''Returns the RMSD calculated with Kabsch's algorithm.'''

    # to np.array
    # struct1 = np.array([ [atom[1], atom[2], atom[3]] for atom in struct1 ])    
    # struct2 = np.array([ [atom[1], atom[2], atom[3]] for atom in struct2 ])    

    # check for consistency in number of atoms
    assert len(struct1) == len(struct2)
    L = len(struct1)
    assert L > 0

    # Center the two fragments to their center of coordinates
    com1 = np.sum(struct1, axis=0) / float(L)
    com2 = np.sum(struct2, axis=0) / float(L)
    struct1 -= com1
    struct2 -= com2

    # Initial residual, see Kabsch.
    E0 = np.sum(np.sum(struct1 * struct1, axis=0), axis=0) + \
         np.sum(np.sum(struct2 * struct2, axis=0), axis=0)

    # This beautiful step provides the answer. V and Wt are the orthonormal
    # bases that when multiplied by each other give us the rotation matrix, U.
    # S, (Sigma, from SVD) provides us with the error!  Isn't SVD great!
    V, S, Wt = np.linalg.svd(np.dot(np.transpose(struct2), struct1))

    # we already have our solution, in the results from SVD.
    # we just need to check for reflections and then produce
    # the rotation. V and Wt are orthonormal, so their det's
    # are +/-1.
    reflect = float(str(float(np.linalg.det(V) * np.linalg.det(Wt))))

    if reflect == -1.0:
        S[-1] = -S[-1]
        V[:,-1] = -V[:,-1]

    RMSD = E0 - (2.0 * sum(S))
    RMSD = np.sqrt(abs(RMSD / L))

    # The rotation matrix U is simply V*Wt
    U = np.dot(V, Wt)
 
    # rotate and translate the molecule
    struct2 = np.dot((struct2), U)
    struct2 = struct2 + com1

    return RMSD, U, struct2, com2, com1


class CUBE:
    def __init__(self, fname):

        f = open(fname, 'r')
        for i in range(2): f.readline() # echo comment
        tkns = f.readline().split() # number of atoms included in the file followed by the position of the origin of the volumetric data
        self.natoms = int(tkns[0])
        self.origin = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])

        # The next three lines give the number of voxels along each axis (x, y, z) followed by the axis vector.
        tkns = f.readline().split() #
        self.NX = int(tkns[0])
        self.X = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])
        tkns = f.readline().split() #
        self.NY = int(tkns[0])
        self.Y = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])
        tkns = f.readline().split() #
        self.NZ = int(tkns[0])
        self.Z = np.array([float(tkns[1]),float(tkns[2]),float(tkns[3])])

        # The last section in the header is one line for each atom consisting of 5 numbers, the first is the atom number, second (?), the last three are the x,y,z coordinates of the atom center.
        self.atoms = []
        for i in range(self.natoms):
            tkns = map(float, f.readline().split())
            self.atoms.append([tkns[0], tkns[2], tkns[3], tkns[4]])

        # Volumetric data
        self.data = np.zeros((self.NX,self.NY,self.NZ))
        i=0
        for s in f:
            for v in s.split():
                self.data[i/(self.NY*self.NZ), (i/self.NZ)%self.NY, i%self.NZ] = float(v)
                i+=1
        if i != self.NX*self.NY*self.NZ: raise NameError, "FSCK!"


    def dump(self, f):

        # output Gaussian cube into file descriptor "f".
        # Usage pattern: f=open('filename.cube'); cube.dump(f); f.close()
        print >>f, "CUBE file\ngenerated by piton _at_ erg.biophys.msu.ru"
        print >>f, "%4d %.6f %.6f %.6f" % (self.natoms, self.origin[0], self.origin[1], self.origin[2])
        print >>f, "%4d %.6f %.6f %.6f"% (self.NX, self.X[0], self.X[1], self.X[2])
        print >>f, "%4d %.6f %.6f %.6f"% (self.NY, self.Y[0], self.Y[1], self.Y[2])
        print >>f, "%4d %.6f %.6f %.6f"% (self.NZ, self.Z[0], self.Z[1], self.Z[2])
        for atom in self.atoms:
            print >>f, "%s %d %s %s %s" % (atom[0], 0, atom[1], atom[2], atom[3])
        for ix in xrange(self.NX):
            for iy in xrange(self.NY):
                for iz in xrange(self.NZ):
                    print >>f, "%.5e " % self.data[ix,iy,iz],
                    if (iz % 6 == 5): print >>f, ''
                print >>f,  ""


    def mask_sphere(self, R, Cx,Cy,Cz):

        # produce spheric volume mask with radius R and center @ [Cx,Cy,Cz]
        # can be used for integration over spherical part of the volume
        m=0*self.data
        for ix in xrange( int(ceil((Cx-R)/self.X[0])), int(floor((Cx+R)/self.X[0])) ):
            ryz=np.sqrt(R**2-(ix*self.X[0]-Cx)**2)
            for iy in xrange( int(ceil((Cy-ryz)/self.Y[1])), int(floor((Cy+ryz)/self.Y[1])) ):
                rz=np.sqrt(ryz**2 - (iy*self.Y[1]-Cy)**2)
                for iz in xrange( int(ceil((Cz-rz)/self.Z[2])), int(floor((Cz+rz)/self.Z[2])) ):
                    m[ix,iy,iz]=1
        return m


def parse_TrDen(cubfile):

    TrDen1 = CUBE(cubfile)
    
    TrD1 = np.asfortranarray(TrDen1.data)
    
    # structure
    struct1 = np.array(TrDen1.atoms)
    
    # calculate the volume element
    dVx1 = TrDen1.X[0]
    dVy1 = TrDen1.Y[1]
    dVz1 = TrDen1.Z[2]
    
    # Grid points
    NX1 = TrDen1.NX
    NY1 = TrDen1.NY
    NZ1 = TrDen1.NZ
    
    # Origin of the cube
    O1 = TrDen1.origin

    return TrD1, dVx1, dVy1, dVz1, NX1, NY1, NZ1, O1, struct1


if __name__ == '__main__':

    geo1 = '1.inc'
    atgeo1 = np.loadtxt(geo1, usecols=[0], dtype="|S5")
    structgeo1 = np.loadtxt(geo1, usecols=[1,2,3]) / au2ang

    temp = 'temp.cub'
    TrDen, dVx, dVy, dVz, NX, NY, NZ, O, struct = parse_TrDen(temp)
    atoms = struct[:,0]
    struct = struct[:,1:]

    # Generate parameters for grid generation
    dV = dVx * dVy * dVz
    N = NX * NY * NZ
    # Reshape TrDen 3D array to 1D array
    TrDen = np.copy(TrDen.reshape(N))

    # Generate 4D array of grid points and reshape it to a 2D array
    grid = np.copy(trden.gengrid(O, dVx, dVy, dVz, NX, NY, NZ))
    grid1 = grid.reshape(N,3)


    RMSD, U, struct, T1, T2 = kabsch(structgeo1, struct)
    print RMSD
    struct = struct * au2ang
    final = np.c_[atoms, struct]

    # Transform grid the same way as the structure
    grid1 = grid1 - T1
    grid1 = np.dot(grid1, U)
    grid1 = grid1 + T2

    with open('1.prj.xyz', 'w') as f:
        f.write('%d\n' % len(final))
        f.write('ppp\n')
        np.savetxt(f, final)


    geo2 = '2.inc'
    atgeo2 = np.loadtxt(geo2, usecols=[0], dtype="|S5")
    structgeo2 = np.loadtxt(geo2, usecols=[1,2,3]) / au2ang

    temp = 'temp.cub'
    TrDen, dVx, dVy, dVz, NX, NY, NZ, O, struct = parse_TrDen(temp)
    atoms = struct[:,0]
    struct = struct[:,1:]
    idxs = [1,2,3,7,8,4,5,18,9,16,6,17,19,20,14,12,10,15,13,11,21]
    idxs = map(lambda x: x-1, idxs)
    struct = struct[idxs]
    atoms = atoms[idxs]

    # Generate parameters for grid generation
    dV = dVx * dVy * dVz
    N = NX * NY * NZ
    # Reshape TrDen 3D array to 1D array
    TrDen = TrDen.reshape(N)

    # Generate 4D array of grid points and reshape it to a 2D array
    grid = np.copy(trden.gengrid(O, dVx, dVy, dVz, NX, NY, NZ))
    grid2 = grid.reshape(N,3)


    RMSD, U, struct, T1, T2 = kabsch(structgeo2, struct)
    print RMSD
    struct = struct * au2ang
    final = np.c_[atoms, struct]

    # Transform grid the same way as the structure
    grid2 = grid2 - T1
    grid2 = np.dot(grid2, U)
    grid2 = grid2 + T2

    with open('2.prj.xyz', 'w') as f:
        f.write('%d\n' % len(final))
        f.write('ppp\n')
        np.savetxt(f, final)


    coupden = trden.couptrde(TrDen, grid1, dV, TrDen, grid2, dV, 1e-5)
    print coupden
    pass
